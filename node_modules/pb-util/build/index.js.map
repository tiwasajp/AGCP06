{"version":3,"file":"index.js","sourceRoot":"","sources":["../index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Matches a JSON object.\n */\nexport type JsonObject = {[key: string]: JsonValue};\n\n/**\n * Matches a JSON array.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JsonArray extends Array<JsonValue> {}\n\n/**\n * Matches any valid JSON value.\n */\nexport type JsonValue = string|number|boolean|null|JsonObject|JsonArray;\n\n/**\n * @typedef {Object} Value\n * @property {string} kind The kind of value. Valid values for this fields are\n *     - `nullValue`\n *     - `numberValue`\n *     - `stringValue`\n *     - `boolValue`\n *     - `structValue`\n *     - `listValue`\n * @property {number} [nullValue] Represents a null value, actual field value\n *     should be `0`.\n * @property {number} [numberValue] Represents a number.\n * @property {string} [stringValue] Represents a string.\n * @property {boolean} [boolValue] Represents a boolean.\n * @property {Struct} [structValue] Represents an object.\n * @property {ListValue} [listValue] Represents an array of values.\n */\nexport interface Value {\n  kind?: string;\n  nullValue?: number;\n  numberValue?: number;\n  stringValue?: string;\n  boolValue?: boolean;\n  structValue?: Struct;\n  listValue?: ListValue;\n}\n\n/**\n * @typedef {Object} Struct\n * @property {Object.<string, Value>} fields The struct fields.\n */\nexport interface Struct {\n  fields?: {[key: string]: Value};\n}\n\n/**\n * @typedef {Object} ListValue\n * @property {Value[]} values The list values.\n */\nexport interface ListValue {\n  values?: Value[];\n}\n\n/**\n * Valid `kind` types\n */\nenum Kind {\n  Struct = 'structValue',\n  List = 'listValue',\n  Number = 'numberValue',\n  String = 'stringValue',\n  Bool = 'boolValue',\n  Null = 'nullValue'\n}\n\nconst toString = Object.prototype.toString;\n\nconst encoders = {\n  [typeOf({})]: v => wrap(Kind.Struct, struct.encode(v)),\n  [typeOf([])]: v => wrap(Kind.List, list.encode(v)),\n  [typeOf(0)]: v => wrap(Kind.Number, v),\n  [typeOf('')]: v => wrap(Kind.String, v),\n  [typeOf(true)]: v => wrap(Kind.Bool, v),\n  [typeOf(null)]: () => wrap(Kind.Null, 0)\n};\n\nfunction typeOf(value: JsonValue): string {\n  return toString.call(value);\n}\n\nfunction wrap(kind: Kind, value): Value {\n  return {kind, [kind]: value};\n}\n\nfunction getKind(value: Value): string | null {\n  if (value.kind) {\n    return value.kind;\n  }\n\n  const validKinds = Object.values(Kind);\n\n  for (const kind of validKinds) {\n    if (value.hasOwnProperty(kind)) {\n      return kind;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Used to encode/decode {@link Value} objects.\n */\nexport const value = {\n  /**\n   * Encodes a JSON value into a protobuf {@link Value}.\n   *\n   * @param {*} value The JSON value.\n   * @returns {Value}\n   */\n  encode(value: JsonValue): Value {\n    const type = typeOf(value);\n    const encoder = encoders[type];\n    if (typeof encoder !== 'function') {\n      throw new TypeError(`Unable to infer type for \"${value}\".`);\n    }\n    return encoder(value);\n  },\n  /**\n   * Decodes a protobuf {@link Value} into a JSON value.\n   *\n   * @throws {TypeError} If unable to determine value `kind`.\n   *\n   * @param {Value} value the protobuf value.\n   * @returns {*}\n   */\n  decode(value: Value): JsonValue {\n    const kind = getKind(value);\n\n    if (!kind) {\n      throw new TypeError(`Unable to determine kind for \"${value}\".`);\n    }\n\n    switch(kind) {\n      case 'listValue':\n        return list.decode(value.listValue);\n      case 'structValue':\n        return struct.decode(value.structValue);\n      case 'nullValue':\n        return null;\n      default:\n        return value[kind] as JsonValue;\n    }\n  }\n};\n\n/**\n * Used to encode/decode {@link Struct} objects.\n */\nexport const struct = {\n  /**\n   * Encodes a JSON object into a protobuf {@link Struct}.\n   *\n   * @param {Object.<string, *>} value the JSON object.\n   * @returns {Struct}\n   */\n  encode(json: JsonObject): Struct {\n    const fields = {};\n    Object.keys(json).forEach(key => {\n      // If value is undefined, do not encode it.\n      if (typeof json[key] === 'undefined') return;\n      fields[key] = value.encode(json[key]);\n    });\n    return {fields};\n  },\n  /**\n   * Decodes a protobuf {@link Struct} into a JSON object.\n   *\n   * @param {Struct} struct the protobuf struct.\n   * @returns {Object.<string, *>}\n   */\n  decode({fields = {}}: Struct): JsonObject {\n    const json = {};\n    Object.keys(fields).forEach(key => {\n      json[key] = value.decode(fields[key]);\n    });\n    return json;\n  }\n};\n\n/**\n * Used to encode/decode {@link ListValue} objects.\n */\nexport const list = {\n  /**\n   * Encodes an array of JSON values into a protobuf {@link ListValue}.\n   *\n   * @param {Array.<*>} values the JSON values.\n   * @returns {ListValue}\n   */\n  encode(values: JsonArray): ListValue {\n    return {\n      values: values.map(value.encode)\n    };\n  },\n  /**\n   * Decodes a protobuf {@link ListValue} into an array of JSON values.\n   *\n   * @param {ListValue} list the protobuf list value.\n   * @returns {Array.<*>}\n   */\n  decode({values = []}: ListValue): JsonArray {\n    return values.map(value.decode);\n  }\n};\n"]}